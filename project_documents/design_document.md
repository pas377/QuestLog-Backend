# [team name] Design Document

## QuestLog Design

## 1. Problem Statement

Users need a place to store their goals and intentions that will make life feel more like an adventure than
an endless toDoList. The app will be very open ended, providing the user with the sense that they are able to be the
author of their own destiny.

A stored username, possibly a login, custom main quests, custom sideQuests, custom rewards, and
an autogenerated character summary(meant to be read in the mornings or as needed), quest branches, journal/note entries(to be placed
where desired).

## 2. Top Questions to Resolve in Review

1. should rewards be editable once created and marked, should moment of contemplations be added?
2. should tempered excitement and reminders to find joy in the walking not the arriving be stressed?
3. should the app be designed to accept a potential avatar slot in the future?

## 3. Use Cases

U1. As a QuestLog user, I want to create a memorable story when I create a custom mainQuest.

U2. As a QuestLog user, I want to create roadMarkers that break the quest up int three or more major sections.
I want commonly impactful suggestions to be available, such as FindTheSword-Attain a weapon that allows you to fight
the financial battles of modern life.
Find the Princess-roadMarkers Health,Presence,Purpose

U3. As a QuestLog user, I want the user to be greeted by name when they start up the app.

U4. As a QuestLog user, I want sideQuests to be quick, easy and fun to make, in order to make
stopping to smell the flowers part of productivity.

U5. As a QuestLog user, I want customRewards to excite the user to attain small rewards along they way, they can be
physically marked, and, or symbolic trinkets and tools.

U6. As a QuestLog user, I want an autoSummary to be generated when the user creates their mainQuest, and for it to be
editable by the user thereafter.

U7. As a QuestLog user, I want prayers and spells section where users can specifically store mantras, affirmations,
prayers, spells, useful information, tactics, and exc. Spell is  a visual representation of a gaol.

U8. I want attachables to be addable to any sectiong of the app, attachables would include spells, items, journal
entries and ect, so I would likely create a parent class of attachables so that they can all be added in a similar
fassion whilst also being orgonized into their own sections of the app.

## 4. Project Scope

*Clarify which parts of the problem you intend to solve. It helps reviewers know
what questions to ask to make sure you are solving for what you say and stops
discussions from getting sidetracked by aspects you do not intend to handle in
your design.*
At the moment as much as I am able to cover.

### 4.1. In Scope

*Which parts of the problem defined in Sections 1 and 3 will you solve with this
design?*
may need to rewrite those.

### 4.2. Out of Scope

*Based on your problem description in Sections 1 and 3, are there any aspects
you are not planning to solve? Do potential expansions or related problems occur
to you that you want to explicitly say you are not worrying about now? Feel free
to put anything here that you think your team can't accomplish in the unit, but
would love to do with more time.*
Custom avatars, and on phone user interfaces, are unfortunately out of scope for this project.

# 5. Proposed Architecture Overview

*Describe broadly how you are proposing to solve for the requirements you
described in Section 3.*

*This may include class diagram(s) showing what components you are planning to
build.*

*You should argue why this architecture (organization of components) is
reasonable. That is, why it represents a good data flow and a good separation of
concerns. Where applicable, argue why this architecture satisfies the stated
requirements.*

# 6. API

## 6.1. Public Models

*Define the data models your service will expose in its responses via your
*`-Model`* package. These will be equivalent to the *`PlaylistModel`* and
*`SongModel`* from the Unit 3 project.*

## 6.2. *First Endpoint*

*Describe the behavior of the first endpoint you will build into your service
API. This should include what data it requires, what data it returns, and how it
will handle any known failure cases. You should also include a sequence diagram
showing how a user interaction goes from user to website to service to database,
and back. This first endpoint can serve as a template for subsequent endpoints.
(If there is a significant difference on a subsequent endpoint, review that with
your team before building it!)*

*(You should have a separate section for each of the endpoints you are expecting
to build...)*

## 6.3 *Second Endpoint*

*(repeat, but you can use shorthand here, indicating what is different, likely
primarily the data in/out and error conditions. If the sequence diagram is
nearly identical, you can say in a few words how it is the same/different from
the first endpoint)*

# 7. Tables

*Define the DynamoDB tables you will need for the data your service will use. It
may be helpful to first think of what objects your service will need, then
translate that to a table structure, like with the *`Playlist` POJO* versus the
`playlists` table in the Unit 3 project.*

# 8. Pages

*Include mock-ups of the web pages you expect to build. These can be as
sophisticated as mockups/wireframes using drawing software, or as simple as
hand-drawn pictures that represent the key customer-facing components of the
pages. It should be clear what the interactions will be on the page, especially
where customers enter and submit data. You may want to accompany the mockups
with some description of behaviors of the page (e.g. “When customer submits the
submit-dog-photo button, the customer is sent to the doggie detail page”)*
